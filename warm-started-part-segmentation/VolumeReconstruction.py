import pymeshlab as pml
import subprocess
from pathlib import Path
import numpy as np
from time import time

class TetGenWrapper(object):
    def __init__(self, tetgen_executable_path:Path) -> None:
        super().__init__()
        self.EXECUTABLE_PATH = tetgen_executable_path
        self.TETRA_PATH = Path('./triangular_mesh.1.ele')
        self.VERT_PATH  = Path('./triangular_mesh.1.node')

    def delete_old_files(self):
        if self.TETRA_PATH.exists():
            self.TETRA_PATH.unlink()
        if self.VERT_PATH.exists():
            self.VERT_PATH.unlink()

    def run_and_parse(self, input_file_path:Path):
        '''Returns a list of vertices and a list of tetrahedra.'''
        self.delete_old_files()
        nb_generated_tet = self.run(input_file_path)
        if nb_generated_tet > 0 and self.TETRA_PATH.exists() and self.VERT_PATH.exists():
            return self.parse_tetgen_output(self.VERT_PATH, self.TETRA_PATH)
        else:
            return [],[]

    #Run the TetGen a compiled executable.
    # After having tried a few different options (GMSH, meshpy)
    # that includes/interface with TetGen, I came to the conclusion that
    # running a standalone executable is simpler and better since you can
    # run the latest version easily. Also, reading files is very fast nowadays
    # so the I/O time is negligible. 
    def run(self, input_file_path: Path):
        nb_tet_tetgen = 0
        if self.EXECUTABLE_PATH.exists() and input_file_path.exists():
            #p: Perform tetrahedralization
            #R: Perform coarsening to obtain less tet
            #F: Do not produce .edge and .face files 
            #q: Mesh refinement followed by the radius-edge ratio of tetrahedron
            proc = subprocess.run([self.EXECUTABLE_PATH.resolve().as_posix(),
                                    '-pRFq10', 
                                    input_file_path.resolve().as_posix()],
                                    capture_output=True)
            for line in proc.stdout.decode('utf-8').split('\n'):
                if line.find('Mesh tetrahedra: ') > 0:
                    nb_tet_tetgen = int(line.split()[2])
        return nb_tet_tetgen

    #Parses the .ele and .node files generated by TetGen
    # and returns a list of vertices and tetrahedra.
    def parse_tetgen_output(self, node_file_path, ele_file_path):
        tet_file_content = []
        with open(ele_file_path, 'r') as tet_file:
            #First line tells how many more line to read
            first_line = tet_file.readline()
            nb_lines = int(first_line.split(' ')[0])
            tet_file_content = np.ndarray((nb_lines,4), dtype=np.int32)
            #Following lines defines tetrahedra
            for i in range(0,nb_lines):
                line = tet_file.readline()
                idx, t1, t2, t3, t4 = line.split()
                tet_file_content[int(idx),:] = np.array([int(t1),int(t2),int(t3),int(t4)])

        vert_file_content = []
        with open(node_file_path, 'r') as vert_file:
            #First line tells how many more line to read
            first_line = vert_file.readline()
            nb_lines = int(first_line.split(' ')[0])
            vert_file_content = np.ndarray((nb_lines,3), dtype=np.float64)
            #Following lines defines vertices
            for i in range(0,nb_lines):
                line = vert_file.readline()
                idx, x, y, z = line.split()
                vert_file_content[int(idx),:] = np.array([float(x),float(y),float(z)])

        return vert_file_content, tet_file_content

class TetraMeshFromPointCloud(object):
    def __init__(self, 
        points: np.ndarray, 
        normals: np.ndarray, 
        tetgen_executable_path: Path, 
        minimal_nb_tetra: int = 100,
        profile_execution: bool = False) -> None:

        self.TRI_PATH   = Path('./triangular_mesh.ply')
        self.surface    = SurfaceFromPointCloud(points, normals, self.TRI_PATH)
        self.tetgen     = TetGenWrapper(tetgen_executable_path)
        self.minimal_nb_tetra = minimal_nb_tetra
        self.profile_execution = profile_execution

    def generate(self):
        '''
        Perform mesh reconstruction and then use tetgen to tetrahedralize the volume.
        Return and array of vertices followed by an array of indices with the indices
        defining a tetrahedron.
        '''
        start_time = time()
        #Try ball-pivoting followed by uniform mesh resampling because its usually faster
        # NOTE: If the point-cloud density it too low, ball-pivoting will fail.
        vertices, triangles = self.surface.ball_pivoting_recon()
        if self.profile_execution:
            print("Ball-pivoting done in {} seconds.".format(time()-start_time))
            start_time = time()

        vertices, tetrahedra = self.tetgen.run_and_parse(self.TRI_PATH)
        if self.profile_execution:
            print("Generated {} tet in {} seconds.".format(len(tetrahedra), time()-start_time))
            start_time = time()
        
        #A very low tet count usually indicates a failure.
        if len(tetrahedra) < self.minimal_nb_tetra:
            #Try to make a triangle mesh from the point cloud using Poisson reconstruction
            vertices, triangles = self.surface.poisson_recon()
            if self.profile_execution:
                print("Poisson Reconstruction done in {} seconds.".format(time()-start_time))
                start_time = time()

            #Generate tetrahedra from the triangle mesh via TetGen
            vertices, tetrahedra = self.tetgen.run_and_parse(self.TRI_PATH)
            if self.profile_execution:
                print("Generated {} tet in {} seconds.".format(len(tetrahedra), time()-start_time))
                start_time = time()
        return np.array(vertices), np.array(tetrahedra)
        

class SurfaceFromPointCloud(object):
    def __init__(self, 
        points: np.ndarray, 
        normals: np.ndarray, 
        output_file_path: Path = None) -> None:
        super().__init__()

        self.points = points
        self.normals= normals
        if output_file_path != None:
            self.output_file_path = output_file_path.resolve().as_posix()

    #Make a watertight mesh out of a point-cloud via Screened Poisson Reconstruction
    #This makes use of the pymeshlab interface to MeshLab,
    # which is better and faster than Open3D for most operations.
    # IMPORTANT: Poisson Reconstruction will fail on very thin structures,
    #            in which case Ball Pivoting can be used.
    #            Poisson reconstruction will also fail when there is a surface within a surface
    #            as produced by sampling parts of a CAD assembly and concatenating the result.
    def poisson_recon(self):
        ms = pml.MeshSet()
        m = pml.Mesh(vertex_matrix=self.points, v_normals_matrix=self.normals)
        ms.add_mesh(m)
        ms.surface_reconstruction_screened_poisson(depth=8, scale=1.1)
        ms.simplification_quadric_edge_collapse_decimation(targetfacenum=1000)
        ms.remove_duplicate_faces()
        ms.select_self_intersecting_faces()
        ms.delete_selected_faces()
        m = ms.current_mesh()
        self.save_mesh(ms, self.output_file_path)
        self.vertices  = m.vertex_matrix()
        self.triangles = m.face_matrix()
        return self.vertices, self.triangles

    #Make a watertight mesh out of a point-cloud via Ball Pivoting
    #This makes use of the pymeshlab interface to MeshLab,
    # which is better and faster than Open3D for most operations.
    # Ball Pivoting works well when the density of the point cloud is high.
    # Otherwise, there will be holes in the reconstructed surface, and if
    # the holes are large enough, the uniform mesh resampling will not close
    # these holes.
    # Uniform mesh resampling is done to "thicken" the surfaces that are not
    # volumetric (thin planes) such that Tetrahedra can be fitted inside.
    #
    # uniform_mesh_resampling and simplification_quadric_edge_collapse_decimation
    # are by far the most costly/slow operations.
    def ball_pivoting_recon(self):
        start_time = time()
        target_face_number = 500
        ms = pml.MeshSet()
        m = pml.Mesh(vertex_matrix=self.points, v_normals_matrix=self.normals)
        ms.add_mesh(m)
        ms.surface_reconstruction_ball_pivoting(ballradius=pml.Percentage(0))
        ms.surface_reconstruction_ball_pivoting(ballradius=pml.Percentage(10))
        ms.surface_reconstruction_ball_pivoting(ballradius=pml.Percentage(20))
        ms.uniform_mesh_resampling(offset=pml.Percentage(55), absdist=True)
        ms.simplification_quadric_edge_collapse_decimation(targetfacenum=target_face_number)
        self.clean_mesh(ms)
        while not self.is_watertight(ms):
            target_face_number = int(0.5*target_face_number)
            ms.simplification_quadric_edge_collapse_decimation(targetfacenum=target_face_number)
            self.clean_mesh(ms)
        m = ms.current_mesh()
        self.save_mesh(ms, self.output_file_path)
        self.vertices  = m.vertex_matrix()
        self.triangles = m.face_matrix()
        return self.vertices, self.triangles

    #Return True if the current mesh from the given PyMeshLab's MeshSet is watertight
    def is_watertight(self, meshset):
        out = meshset.compute_geometric_measures()
        return 'mesh_volume' in out

    #Clean the current mesh from the given PyMeshLab's MeshSet
    def clean_mesh(self, meshset):
        meshset.repair_non_manifold_edges()
        meshset.close_holes(newfaceselected=False)
        meshset.remove_duplicate_faces()
        meshset.select_self_intersecting_faces()
        meshset.delete_selected_faces()

    #Save the current mesh from the given PyMeshLab's MeshSet
    def save_mesh(self, meshset, output_file_path):
        if output_file_path != None:
            meshset.save_current_mesh(output_file_path, 
                binary=False, \
                save_vertex_quality = False, \
                save_vertex_flag    = False, \
                save_vertex_color   = False, \
                save_vertex_coord   = True, \
                save_vertex_normal  = False, \
                save_vertex_radius  = False, \
                save_face_quality   = False, \
                save_face_flag      = False, \
                save_face_color     = False, \
                save_wedge_color    = False, \
                save_wedge_texcoord = False, \
                save_wedge_normal   = False)